#lang racket
(require "day7data.rkt")
(require racket/hash)

(define (process in (fs (hash)))
  (let loop ((cur (read-line in)) (acc fs))
    (cond ((or (eof-object? cur)
               (string=? cur "$ cd ..")) acc)
          ((string-prefix? cur "$ cd")
           (let ((arg (third (string-split cur " "))))
             (let ((dir (process in (hash-ref acc arg hash))))
               (loop (read-line in) (hash-update acc arg (lambda (x) (hash-union x dir)) (hash))))))
          ((or
            (string=? cur "$ ls")
            (string-prefix? cur "dir"))
           (loop (read-line in) acc))
          (else
           (let ((args (string-split cur " ")))
             (loop (read-line in) (hash-set acc (second args) (string->number (first args)))))))))
(define (part1 fs)
  (define (finish h)
    (for/fold ((sum 0)
               #:result sum)
              ((v (in-list h)))
      (if (>= 100000 v)
          (+ sum v)
          sum)))
  (define (go h)
    (let loop ((rem (hash-keys h)) (cur-acc 0) (acc '()))
      (if (null? rem)
          (values cur-acc acc)
          (let ((v (hash-ref h (car rem))))
            (if (number? v)
                (loop (cdr rem) (+ cur-acc v) acc)
                (call-with-values (lambda () (go v)) (lambda (x y) (loop (cdr rem) (+ cur-acc x) (append y acc (list x))))))))))
  (call-with-values (lambda () (go fs)) (lambda (x y) (finish y))))
(define (part2 fs)
  (define (finish lst)
    (let ((ref (- 30000000 (- 70000000 (car lst)))))
      (for/fold
       ((out +inf.0)
      #:result out)
     ((v lst))
      (if (>= v ref)
          (min v out)
          out))))
  (define (go h)
    (let loop ((rem (hash-keys h)) (cur-acc 0) (acc '()))
      (if (null? rem)
          (values cur-acc acc)
          (let ((v (hash-ref h (car rem))))
            (if (number? v)
                (loop (cdr rem) (+ cur-acc v) acc)
                (call-with-values (lambda () (go v)) (lambda (x y) (loop (cdr rem) (+ cur-acc x) (cons x (append y acc))))))))))
  (call-with-values (lambda () (go fs)) (lambda (x y) (finish y))))
(part2 (call-with-input-string data process))