#lang racket
(require "day5data.rkt")
(define (process in)
  (define (process-stacks)
    (let loop ((cur-line (read-line in)) (out (hash)))
      (cond
        ((string=? "" cur-line)  out)
        ((string-prefix? cur-line " 1") (loop (read-line in) out))
        (else
         (let i-loop ((rem-line (substring cur-line 3))
                      (cur-col (substring cur-line 0 3))
                      (i 1)
                      (i-out out))
              (cond ((string=? rem-line "")
                     (if (string=? cur-col "   ")
                         (loop (read-line in) (hash-set i-out i '()))
                         (loop (read-line in) (hash-update i-out i (lambda (x) (append x (list (string-ref cur-col 1)))) '()))))
                    ((string=? cur-col "   ")
                     (i-loop (substring rem-line 4) (substring rem-line 1 4) (add1 i) (hash-set i-out i '())))
                    (else                      
                       (i-loop (substring rem-line 4) (substring rem-line 1 4) (add1 i) (hash-update i-out i (lambda (x) (append x (list (string-ref cur-col 1)))) '())))))))))
  (define (process-instr)
    (for/fold ((out '())
               #:result out)
              ((line (in-lines in)))
      (let ((m (regexp-match #px"move (\\d*) from (\\d*) to (\\d*)" line)))
        (append out (list (map string->number (drop m 1)))))))
  (values (process-stacks) (process-instr)))



(define (part1 in)
  (define (move stacks n from to)
    (let loop ((rem n) (hold (car (hash-ref stacks from))) (out (hash-update stacks from (lambda (x) (cdr x)))))
      (cond ((zero? rem) out)
            ((null? hold) (loop rem (car (hash-ref out from)) (hash-update out from (lambda (x) (cdr x)))))
            (else
             (loop (sub1 rem) '() (hash-update out to (lambda (x) (cons hold x))))))))
  (define (read-top stacks)
    (let loop ((i 1) (out '()))
      (if (hash-has-key? stacks i)
          (loop (add1 i) (append out (list (car (hash-ref stacks i)))))
          (list->string out))))
  (let-values (((sta instr) (process in)))
    (let loop ((rem instr) (out sta))
      (if (null? rem)
          (read-top out)
          (loop (cdr rem) (apply (lambda (n f t) (move out n f t)) (car rem)))))))
(define (part2 in)
  (define (move stacks n from to)
    (let ((moved (take (hash-ref stacks from) n)))
      (hash-update
       (hash-update stacks from (lambda (x) (drop x n)))
       to
       (lambda (x) (append moved x)))))
  (define (read-top stacks)
    (let loop ((i 1) (out '()))
      (if (hash-has-key? stacks i)
          (loop (add1 i) (append out (list (car (hash-ref stacks i)))))
          (list->string out))))
  (let-values (((sta instr) (process in)))
    (let loop ((rem instr) (out sta))
      (if (null? rem)
          (read-top out)
          (loop (cdr rem) (apply (lambda (n f t) (move out n f t)) (car rem)))))))

(call-with-input-string test-data part2)
(call-with-input-string data part2)